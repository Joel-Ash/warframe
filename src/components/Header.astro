---
import { SITE_TITLE } from "../consts";
import HeaderLink from "./HeaderLink.astro";
---

<header>
  <nav>
    <h2><a href="/main">{SITE_TITLE}</a></h2>

    <div class="internal-links">
      <HeaderLink href="/main">메인</HeaderLink>
      <HeaderLink href="/guide">가이드</HeaderLink>
      <HeaderLink href="/moding">모딩</HeaderLink>
    </div>

    <div class="right-slot" aria-hidden="true"></div>
  </nav>
</header>

<style>
  header {
    position: sticky;
    top: 0;
    z-index: 9999;

    margin: 0;
    padding: 0 1em;
    background: #ffffff;
    box-shadow: 0 2px 8px rgba(var(--black), 0.05);
  }

  /* ✅ 3컬럼(좌/중/우)로 탭 위치 완전 고정 */
  nav {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: center;
    min-height: 56px;
  }

  h2 {
    margin: 0;
    font-size: 1em;
    justify-self: start;
    min-width: 0;
  }

  h2 a {
    text-decoration: none;
    color: rgb(var(--gray-dark));
    font-weight: 700;
    display: inline-flex;
    align-items: center;
    white-space: nowrap;
  }

  .internal-links {
    justify-self: center;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .right-slot {
    justify-self: end;
  }

  nav a {
    display: flex;
    align-items: center;
    height: 100%;
    padding: 0 0.9rem;
    border-bottom: 4px solid transparent;
    text-decoration: none;

    color: rgb(var(--gray-dark));
    font-weight: 700;
    letter-spacing: 0.02em;
    white-space: nowrap;
  }

  nav a.active {
    border-bottom-color: var(--accent);
    color: var(--accent);
    font-weight: inherit;
  }

  @media (max-width: 720px) {
    header {
      padding: 0 0.75em;
    }
    nav a {
      padding: 0 0.7rem;
    }
  }

  @media (prefers-color-scheme: dark) {
    header {
      background: #111318;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.35);
    }
    h2 a {
      color: rgba(255, 255, 255, 0.9);
    }
    nav a {
      color: rgba(255, 255, 255, 0.7);
    }
    nav a.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }
  }
</style>

<script is:inline>
  (() => {
    try {
      if (window.__astroStateKeeperInstalled) return;
      window.__astroStateKeeperInstalled = true;

      // =========================================================
      // 0) 탭 이동 감지 → 이전 페이지 details 상태 리셋
      // =========================================================
      const TAB_KEY = "current-tab";
      const PATH_KEY = "last-path";

      const getTab = (path) => {
        if (path.startsWith("/guide")) return "guide";
        if (path.startsWith("/moding")) return "moding";
        if (path.startsWith("/main")) return "main";
        return "other";
      };

      const prevTab = sessionStorage.getItem(TAB_KEY);
      const prevPath = sessionStorage.getItem(PATH_KEY);
      const currentTab = getTab(location.pathname);

      if (prevTab && prevTab !== currentTab && prevPath) {
        sessionStorage.removeItem("details:" + prevPath);
      }

      sessionStorage.setItem(TAB_KEY, currentTab);
      sessionStorage.setItem(PATH_KEY, location.pathname);

      // =========================================================
      // 1) 탭 클릭 이동 시: (모바일 포함) 다음 페이지는 무조건 최상단
      // =========================================================
      const FORCE_TOP_KEY = "force-top-next-path";

      const normPath = (href) => {
        try {
          const u = new URL(href, location.origin);
          return u.pathname;
        } catch (_) {
          return String(href).split("#")[0].split("?")[0];
        }
      };

      const isTabHref = (pathname) =>
        pathname === "/main" ||
        pathname === "/guide" ||
        pathname === "/moding" ||
        pathname.startsWith("/main") ||
        pathname.startsWith("/guide") ||
        pathname.startsWith("/moding");

      const markForceTopForPath = (nextPath) => {
        sessionStorage.setItem(FORCE_TOP_KEY, nextPath);
        sessionStorage.removeItem("scroll:" + nextPath);
      };

      const markForceTopIfTab = (e) => {
        const a = e.target?.closest && e.target.closest("a[href]");
        if (!a) return;

        const href = a.getAttribute("href");
        if (!href) return;

        if (a.target === "_blank" || a.hasAttribute("download")) return;
        if (/^mailto:/i.test(href) || /^tel:/i.test(href)) return;

        const nextPath = normPath(href);
        if (!isTabHref(nextPath)) return;

        markForceTopForPath(nextPath);
      };

      // ✅ 모바일: click보다 먼저 잡는다
      document.addEventListener("pointerdown", markForceTopIfTab, true);
      // ✅ 데스크탑/키보드 접근성용
      document.addEventListener("click", markForceTopIfTab, true);

      // =========================================================
      // 2) 스크롤 기억/복원 (탭 이동 시는 최상단 강제)
      // =========================================================
      if ("scrollRestoration" in history) {
        history.scrollRestoration = "manual";
      }

      const scrollKey = () => "scroll:" + location.pathname;

      const restoreScroll = () => {
        const forcePath = sessionStorage.getItem(FORCE_TOP_KEY);
        if (forcePath === location.pathname) {
          sessionStorage.removeItem(FORCE_TOP_KEY);
          sessionStorage.removeItem(scrollKey());
          requestAnimationFrame(() => window.scrollTo(0, 0));
          return;
        }

        const saved = sessionStorage.getItem(scrollKey());
        if (saved !== null) {
          const y = Number(saved);
          if (!Number.isNaN(y)) requestAnimationFrame(() => window.scrollTo(0, y));
        }
      };

      const saveScroll = () => {
        sessionStorage.setItem(scrollKey(), String(window.scrollY || 0));
      };

      window.addEventListener("pageshow", restoreScroll);
      window.addEventListener("pagehide", saveScroll);
      window.addEventListener("beforeunload", saveScroll);

      // =========================================================
      // 3) 모바일 제스처(스와이프)로 탭 이동 (✅ 페이지 어디서든)
      //    - 좌/우 스와이프로: main <-> guide <-> moding
      //    - summary(폴더바) 위에서 시작해도 허용 (핵심)
      //    - 스와이프 확정되면 "다음 click 1회" 캡처해서 링크/summary 클릭 방지
      //    - pointer 이벤트 + touch 폴백
      // =========================================================
      const TAB_ORDER = ["/main", "/guide", "/moding"];

      const currentTabRoot = (() => {
        if (location.pathname.startsWith("/guide")) return "/guide";
        if (location.pathname.startsWith("/moding")) return "/moding";
        return "/main";
      })();

      const getAdjacentTab = (dir) => {
        const i = TAB_ORDER.indexOf(currentTabRoot);
        if (i === -1) return null;
        const ni = i + dir;
        if (ni < 0 || ni >= TAB_ORDER.length) return null;
        return TAB_ORDER[ni];
      };

      const isTouchLike = () =>
        ("ontouchstart" in window) ||
        (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) ||
        window.matchMedia?.("(pointer: coarse)")?.matches;

      // ✅ 입력 폼만 제외: a/summary/카드 위에서도 스와이프 가능
      const shouldIgnoreGestureStart = (target) => {
        if (!target) return true;
        const el = target.closest ? target.closest("input, textarea, select") : null;
        return !!el;
      };

      const SWIPE_MIN_X = 72;
      const SWIPE_MAX_Y = 44;
      const SWIPE_MIN_VX = 0.10;

      // 스와이프 확정 이후, 다음 click 1회 차단
      let blockNextClickOnce = false;
      const blockClickCapture = (e) => {
        if (!blockNextClickOnce) return;
        blockNextClickOnce = false;
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
      };
      document.addEventListener("click", blockClickCapture, true);

      const doSwipeNav = (dir) => {
        const next = getAdjacentTab(dir);
        if (!next) return false;

        markForceTopForPath(next);
        blockNextClickOnce = true;
        location.assign(next);
        return true;
      };

      // pointer 기반
      if (isTouchLike() && "PointerEvent" in window) {
        let sx = 0, sy = 0, st = 0;
        let tracking = false;
        let locked = false;

        const onPointerDown = (e) => {
          if (locked) return;
          if (e.pointerType && e.pointerType !== "touch" && e.pointerType !== "pen") return;
          if (shouldIgnoreGestureStart(e.target)) return;
          if (e.isPrimary === false) return;

          tracking = true;
          sx = e.clientX;
          sy = e.clientY;
          st = performance.now();
        };

        const onPointerMove = (e) => {
          if (!tracking || locked) return;

          const dx = e.clientX - sx;
          const dy = e.clientY - sy;

          // 세로 스크롤 의도가 확실하면 포기
          if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > SWIPE_MAX_Y) {
            tracking = false;
          }
        };

        const onPointerUp = (e) => {
          if (!tracking || locked) return;
          tracking = false;

          const dx = e.clientX - sx;
          const dy = e.clientY - sy;
          const dt = Math.max(1, performance.now() - st);
          const vx = Math.abs(dx) / dt;

          if (Math.abs(dx) < SWIPE_MIN_X) return;
          if (Math.abs(dy) > SWIPE_MAX_Y) return;
          if (vx < SWIPE_MIN_VX) return;

          const dir = dx < 0 ? +1 : -1;

          locked = true;
          if (!doSwipeNav(dir)) locked = false;
        };

        document.addEventListener("pointerdown", onPointerDown, true);
        document.addEventListener("pointermove", onPointerMove, true);
        document.addEventListener("pointerup", onPointerUp, true);
        document.addEventListener("pointercancel", () => { tracking = false; }, true);
      }
      // touch 폴백
      else if (isTouchLike()) {
        let sx = 0, sy = 0, st = 0;
        let tracking = false;
        let locked = false;

        const onTouchStart = (e) => {
          if (locked) return;
          if (!e.touches || e.touches.length !== 1) return;
          if (shouldIgnoreGestureStart(e.target)) return;

          const t = e.touches[0];
          tracking = true;
          sx = t.clientX;
          sy = t.clientY;
          st = performance.now();
        };

        const onTouchMove = (e) => {
          if (!tracking || locked) return;
          const t = e.touches[0];
          const dx = t.clientX - sx;
          const dy = t.clientY - sy;

          if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > SWIPE_MAX_Y) {
            tracking = false;
          }
        };

        const onTouchEnd = (e) => {
          if (!tracking || locked) return;
          tracking = false;

          const t = (e.changedTouches && e.changedTouches[0]) || null;
          if (!t) return;

          const dx = t.clientX - sx;
          const dy = t.clientY - sy;
          const dt = Math.max(1, performance.now() - st);
          const vx = Math.abs(dx) / dt;

          if (Math.abs(dx) < SWIPE_MIN_X) return;
          if (Math.abs(dy) > SWIPE_MAX_Y) return;
          if (vx < SWIPE_MIN_VX) return;

          const dir = dx < 0 ? +1 : -1;

          locked = true;
          if (!doSwipeNav(dir)) locked = false;
        };

        document.addEventListener("touchstart", onTouchStart, { capture: true, passive: true });
        document.addEventListener("touchmove", onTouchMove, { capture: true, passive: true });
        document.addEventListener("touchend", onTouchEnd, { capture: true, passive: true });
        document.addEventListener("touchcancel", () => { tracking = false; }, { capture: true, passive: true });
      }

      // =========================================================
      // 4) 아코디언 애니메이션 (grid-template-rows: 0fr ↔ 1fr)
      //    ✅ 닫힘 애니메이션: 끝난 뒤 open=false
      //    ✅ "동시" 동작: A 닫히면서 B 바로 열리기
      // =========================================================
      const detailsKey = () => "details:" + location.pathname;
      const DSEL = "details[data-part]";

      const allDetails = () => Array.from(document.querySelectorAll(DSEL));
      const bodyOf = (d) => d.querySelector(".accordion-body");
      const innerOf = (d) => d.querySelector(".accordion-inner");

      const OPEN_MS = 420;
      const CLOSE_MS = 380;
      const EASE_OPEN = "cubic-bezier(.12, 1.2, .25, 1)";
      const EASE_CLOSE = "cubic-bezier(.22, .61, .36, 1)";

      const running = new WeakMap();

      const cleanup = (d) => {
        const rec = running.get(d);
        if (rec?.cleanup) rec.cleanup();
        running.delete(d);
      };

      const applyInstantState = (d, open) => {
        const body = bodyOf(d);
        const inner = innerOf(d);
        if (!body || !inner) return;

        cleanup(d);

        body.style.transition = "none";
        inner.style.transition = "none";

        body.style.display = "grid";
        body.style.gridTemplateRows = open ? "1fr" : "0fr";
        body.style.overflow = "hidden";

        inner.style.minHeight = "0";
        inner.style.opacity = open ? "1" : "0";
        inner.style.transform = open
          ? "translateY(0) scaleY(1)"
          : "translateY(-6px) scaleY(.985)";
        inner.style.transformOrigin = "top";

        requestAnimationFrame(() => {
          body.style.transition = "";
          inner.style.transition = "";
        });
      };

      const animateTo = (d, toOpen) => {
        const body = bodyOf(d);
        const inner = innerOf(d);
        if (!body || !inner) return Promise.resolve();

        cleanup(d);

        body.style.display = "grid";
        body.style.overflow = "hidden";
        inner.style.minHeight = "0";
        inner.style.transformOrigin = "top";

        const ms = toOpen ? OPEN_MS : CLOSE_MS;
        const ease = toOpen ? EASE_OPEN : EASE_CLOSE;

        body.style.transition = `grid-template-rows ${ms}ms ${ease}`;
        body.style.gridTemplateRows = toOpen ? "1fr" : "0fr";

        const anim = inner.animate(
          toOpen
            ? [
                { opacity: 0, transform: "translateY(-6px) scaleY(.985)" },
                { opacity: 1, transform: "translateY(0) scaleY(1)" },
              ]
            : [
                { opacity: 1, transform: "translateY(0) scaleY(1)" },
                { opacity: 0, transform: "translateY(-6px) scaleY(.985)" },
              ],
          { duration: ms, easing: ease, fill: "both" }
        );

        let done = false;
        let resolvePromise;
        const p = new Promise((res) => (resolvePromise = res));

        const finish = () => {
          if (done) return;
          done = true;

          window.clearTimeout(t);
          body.removeEventListener("transitionend", onBodyEnd);

          body.style.transition = "";
          inner.style.transition = "";

          if (toOpen) {
            inner.style.opacity = "1";
            inner.style.transform = "translateY(0) scaleY(1)";
          } else {
            inner.style.opacity = "0";
            inner.style.transform = "translateY(-6px) scaleY(.985)";
          }

          cleanup(d);
          resolvePromise();
        };

        const onBodyEnd = (e) => {
          if (e.propertyName !== "grid-template-rows") return;
          finish();
        };

        body.addEventListener("transitionend", onBodyEnd);
        const t = window.setTimeout(() => finish(), ms + 80);

        running.set(d, {
          cleanup: () => {
            window.clearTimeout(t);
            body.removeEventListener("transitionend", onBodyEnd);
            try { anim.cancel(); } catch (_) {}
          },
        });

        anim.finished.catch(() => {});
        return p;
      };

      const saveDetails = () => {
        const all = allDetails();
        if (all.length === 0) return;

        const opened = all
          .filter((d) => d.open)
          .map((d) => d.getAttribute("data-part"))
          .find(Boolean);

        if (!opened) sessionStorage.removeItem(detailsKey());
        else sessionStorage.setItem(detailsKey(), JSON.stringify(opened));
      };

      const closeOthersConcurrent = (current) => {
        const tasks = [];
        for (const d of allDetails()) {
          if (d !== current && d.open) {
            tasks.push(
              animateTo(d, false).then(() => {
                d.open = false;
              })
            );
          }
        }
        return tasks;
      };

      const isBackForwardNav = (pageshowEvent) => {
        if (pageshowEvent && pageshowEvent.persisted) return true;
        try {
          const nav = performance.getEntriesByType("navigation")[0];
          if (nav && nav.type === "back_forward") return true;
        } catch (_) {}
        return false;
      };

      const restoreDetails = (e) => {
        const backForward = isBackForwardNav(e);

        for (const d of allDetails()) {
          const body = bodyOf(d);
          const inner = innerOf(d);
          if (!body || !inner) continue;
          applyInstantState(d, d.open);
        }

        const raw = sessionStorage.getItem(detailsKey());
        if (!raw) return;

        let opened;
        try {
          opened = JSON.parse(raw);
        } catch {
          return;
        }
        if (typeof opened !== "string" || !opened) return;

        const el = document.querySelector(`${DSEL}[data-part="${opened}"]`);
        if (!el) return;

        for (const d of allDetails()) {
          if (d !== el && d.open) d.open = false;
        }
        el.open = true;

        if (backForward) {
          applyInstantState(el, true);
          return;
        }

        requestAnimationFrame(() => animateTo(el, true));
      };

      window.addEventListener("pageshow", restoreDetails);

      document.addEventListener(
        "click",
        async (e) => {
          const summary = e.target.closest("summary");
          if (!summary) return;

          const details = summary.closest(DSEL);
          if (!details) return;

          e.preventDefault();

          const body = bodyOf(details);
          const inner = innerOf(details);
          if (!body || !inner) {
            details.open = !details.open;
            saveDetails();
            return;
          }

          if (details.open) {
            await animateTo(details, false);
            details.open = false;
            saveDetails();
            return;
          }

          const closeTasks = closeOthersConcurrent(details);

          details.open = true;
          const openTask = animateTo(details, true);

          await Promise.all([...closeTasks, openTask]);

          saveDetails();
        },
        true
      );

      window.addEventListener("pagehide", () => {
        saveDetails();
        for (const d of allDetails()) cleanup(d);
      });

      window.addEventListener("beforeunload", saveDetails);
    } catch (e) {}
  })();
</script>
